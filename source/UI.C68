/***
 *			User Interface for Nuclear Rush
 *				Copyright 1993, Futurescape Productions
 *				All Rights Reserved
 ***/

#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>

#include "game.h"
#include "gems.h"

#define	NOASCII	TRUE
#define	FOCUS		TRUE

#define	WCES94	TRUE

#define	TEST_ANM	FALSE

//#define EXTRA_INIT_FAILURE_DIAG //rww - display error code when there's no head tracker

extern PLAYER		Player;

extern UWORD	SYS_BASECHR;
extern UWORD	SYS_BASECHR1;
extern UWORD	SYS_LASTCHR;
extern WORD		SYS_LASTSPR;
extern UWORD	SYS_CHRATTR;		/* Character Attributes */
extern BYTE		SEND_LEFT;			/*	True if currently sending left data	*/
extern WORD		SYS_DOHEADSET;
extern WORD		SYS_READHEAD;

#define	FADETIME		10
#define	HEADTRACK	TRUE

extern void		SendAnimPal(UWORD *anim_file);
extern void	DispFrame(UWORD *anim_file,WORD anim,WORD frame,WORD xp,WORD yp);
extern void		DispMap(UWORD *map_file);
extern void		DispBMap(UWORD *map_file);
extern void		SetMapPal(UWORD *map_file);

BYTE				SYS_FLICKER;

UWORD				SYS_VR_MODE;

/***
 *		User Interface Globals:
 ***/

WORD	UI_Continue;		/* Continue counter, 0 = new game */
WORD	UI_GameLevel;
WORD	UI_NumContinues;
WORD	UI_Control;
char	UI_AccessCode[10];
WORD	UI_DemoMode;
WORD	UI_StopDemo;

UWORD		SYS_MINFDIST;
UWORD		SYS_MAXFDIST;
UWORD		SYS_AVGFDIST;
UWORD		SYS_DISTDIV;		/* Distance Divisor */

UWORD		STATS_SHOTS;
UWORD		STATS_HITS;

/***
 *		External Art files:
 ***/

extern	UWORD	desert_map;
extern	UWORD	hud_map;
extern	UWORD	midwest_map;

/****** Globals *******/
extern WORD		ScreenCol;
extern WORD		ScreenRow;		/* Where all Console I/O takes place from */
extern WORD		SYS_SCROLLX;
extern UWORD	SYS_LASTCHR;
extern volatile	LONG	SYS_VCNT;

#include	"font.c68"

const UWORD	UI_Pal[] = {
	1,	/* Starting color index */
	15,	/* Number of colors */
	0x00E8,
	0x00C6,
	0x00A4,
	0x0082,
	0x0062,
	0x0040,
	0x0020,
	0x0EA6,
	0x000C,
	0x00C0,
	0x0C00,
	0x0EEE,
	0x0AAA,
	0x0444,
	0x0000,
	-1,	/* End marker */
};

const UWORD	Title_Pal[] = {
	1,	/* Index */
	15,	/* Count */
	0x06EC,
	0x00E8,
	0x00C6,
	0x00A4,
	0x0082,
	0x0062,
	0x0040,
	0x0020,
	0x0000,
	0x0888,
	0x0AAA,
	0x0EEE,
	0x0666,
	0x0EC8,
	0x0444,
	33,	/* Index */
	15,	/* Count */
	0x0026,
	0x0248,
	0x024A,
	0x006E,
	0x00AE,
	0x00CE,
	0x06EE,
	0x0EEE,
	0x0EEE,
	0x0CCC,
	0x0AAA,
	0x0888,
	0x0666,
	0x0444,
	0x0000,
	49,	/* Index */
	15,	/* Count */
	0x000C,
	0x000E,
	0x00EE,
	0x00E0,
	0x0080,
	0x0C00,
	0x0E00,
	0x0EEE,
	0x0EEE,
	0x0CCC,
	0x0AAA,
	0x0888,
	0x0666,
	0x0444,
	0x0000,
	-1		/* End of palette */
};
/***
 *		UI_LoadLED:		Load the LED font into VDP RAM
 ***/

/***
			Current VRAM Memory Map:

			With 8x8 ASCII Font:
			Logo & ASCII Font		$0000 - $1280
			Background Maps		$1280 -

			Without 8x8 ASCII Font:
			Background Maps		$0020 -

			Sprite Data
			Sprite List				$B400
			Horizontal Scroll		$B800
			LED Font	RED			$B820
			LED Font	GREEN			$BB00	- $BDE0
			Screen A					$C000 - $DFFF
			Screen B					$E000 - $FFFF

 ***/

#define	RLEDAddr	0xB820	/* Right after the Horizontal scroll list */
#define	GLEDAddr	0xBB00	/* Right after the Red LED Font */
#define	RLEDIndex	(RLEDAddr/32)
#define	GLEDIndex	(GLEDAddr/32)

/***
 *		UI_Do40:		Switch to 40 column mode
 ***/

UI_Do40()
{
	short		i;

 	DisableInts();
	WVCTRL = 0x8104;		/* Kill display */
	for (i=0; i<10000; i++)
		;
	WVCTRL = 0x8C81;		/* 40 Column mode */
	for (i=0; i<10000; i++)
		;
	WVCTRL = 0x8174;		/* Resume display */
	EnableInts();
}

/***
 *		UI_Do32:		Swith to 32 column mode
 ***/

UI_Do32()
{
	short		i;

 	DisableInts();
	WVCTRL = 0x8104;		/* Kill display */
	for (i=0; i<10000; i++)
		;
	WVCTRL = 0x8C00;		/* 32 Column mode */
	for (i=0; i<10000; i++)
		;
	WVCTRL = 0x8174;		/* Resume display */
	EnableInts();
}

UI_LoadLED()
{
	const ULONG		*ptr;
	short				i;
	ULONG				*vdata;

	vdata = (ULONG *)0xC00000;
	DisableInts();
	ptr = RED_LEDFont;
	SYS_SetVAddr(RLEDAddr);
	for (i=0; i < 24*8; i++)
		*vdata = *ptr++;
	ptr = GREEN_LEDFont;
	SYS_SetVAddr(GLEDAddr);
	for (i=0; i < 24*8; i++)
		*vdata = *ptr++;
	EnableInts();
}

UI_PrintLED(const char	*str, UWORD	color)
{
	const char		*ptr;
	const UWORD		*wptr;
	BYTE				chr;
	UWORD				Addr;
	UWORD				mask;

	SYS_DCListHold();
	ptr = str;
	mask = (color ? GLEDIndex + 0x8000 : RLEDIndex + 0x8000);
	while (*ptr) {
		chr = *ptr;
		chr = toupper(chr);
		/* Check to make sure character is printable */
		if (chr >= ' ' && chr <= '_') {
			/* Compute address of character to print */
			Addr = (ScreenRow * (64 * 2)) + (ScreenCol * 2) + 0xE000;
			wptr = &ASCII2LED[(chr - ' ') * 4];
			SYS_DCAddVAddr(Addr);
			SYS_DCAddData(*wptr++ + mask);
			SYS_DCAddData(*wptr++ + mask);
			SYS_DCAddVAddr(Addr+(64*2));
			SYS_DCAddData(*wptr++ + mask);
			SYS_DCAddData(*wptr++ + mask);
			if (chr == ' ' || chr == '.' || chr == ',' || chr == '-')
				ScreenCol++;
			else
				ScreenCol += 2;
		} else {
			/* Emulate control characters */
			if (chr == '\n') {
				ScreenCol = 0;
				ScreenRow += 2;
			}
		}
		ptr++;
	}
	SYS_DCListGo();
}

void
UI_ClearScreen(UWORD	Addr)
{
	register int	i;

	DisableInts();
	SYS_SetVAddr(Addr);
	for (i=0; i < 4096; i++)
		VDATA = 0;
	ScreenRow = ScreenCol = 0;
	EnableInts();
}

UI_FlashRed()
{
	int					index;
	WORD					TmpBuffer[64];
	extern WORD			PalBuffer[64];

	/* Flash palette RED and then restore */
	memcpy(TmpBuffer,PalBuffer,128);
	for (index=0; index < 48; index++)
		PalBuffer[index] = 0x000E;
	SYS_WaitFrame();
	SYS_SendPalette();
	memcpy(PalBuffer,TmpBuffer,128);
	SYS_WaitFrame();
	SYS_WaitFrame();
	SYS_SendPalette();
}

UI_FlashGreen()
{
	int					index;
	WORD					TmpBuffer[64];
	extern WORD			PalBuffer[64];

	/* Flash palette RED and then restore */
	memcpy(TmpBuffer,PalBuffer,128);
	for (index=0; index < 48; index++)
		PalBuffer[index] = 0x00E0;
	SYS_WaitFrame();
	SYS_SendPalette();
	memcpy(PalBuffer,TmpBuffer,128);
	SYS_WaitFrame();
	SYS_WaitFrame();
	SYS_SendPalette();
}

UI_FlashBlue()
{
	int					index;
	WORD					TmpBuffer[64];
	extern WORD			PalBuffer[64];

	/* Flash palette RED and then restore */
	memcpy(TmpBuffer,PalBuffer,128);
	for (index=0; index < 48; index++)
		PalBuffer[index] = 0x0E00;
	SYS_WaitFrame();
	SYS_SendPalette();
	memcpy(PalBuffer,TmpBuffer,128);
	SYS_WaitFrame();
	SYS_WaitFrame();
	SYS_SendPalette();
}

UI_KillSprList()
{
	register short		i;
	extern UWORD		SPR_Llength;
	extern UWORD		SPR_Rlength;
	extern UWORD		SPR_NLlength;
	extern UWORD		SPR_NRlength;
	extern UWORD		CHR_1length;
	extern UWORD		CHR_2length;
	extern UWORD		CHR_3length;
	extern UWORD		NEW_HORZLEN;
	extern UWORD		SYS_HORZLEN;			/* Flag to send the horizon */

	DisableInts();
	SPR_Llength = 0;
	SPR_Rlength = 0;
	SPR_NLlength = 0;
	SPR_NRlength = 0;
	CHR_1length = 0;
	CHR_2length = 0;
	CHR_3length = 0;
	SYS_SetVAddr(0xB400);
	for (i=8; i > 0; i--)
		VDATA = 0;
	SYS_HORZLEN = NEW_HORZLEN = 0;
	EnableInts();
}

/***
 *		UI_InitVDP:		Clears the background color and scroll registers
 ***/

UI_InitVDP()
{
	WORD				i;
#if DOUBLE_BUFFER_VSCROLL
	extern WORD		SYS_VSCROLLA[];
	extern WORD		SYS_VSCROLLB[];
#else
	extern WORD		SYS_VSCROLL[];
#endif
	extern WORD		SYS_NEWXA;
	extern WORD		SYS_NEWXB;

	SYS_NEWXA = SYS_NEWXB = SYS_SCROLLX = 0;
	DisableInts();
	VCTRL = 0x40000010l;
	for (i=0; i < 40; i++)
		VDATA = 0;
	for (i=0; i < 20; i++)
	{
#if DOUBLE_BUFFER_VSCROLL
		SYS_VSCROLLA[i] = SYS_VSCROLLB[i] = 0;
#else	
		SYS_VSCROLL[i] = 0;
#endif
	}
	SYS_SetVAddr(0xB800);
	VDATA = 0;
	VDATA = 0;
	/* Make one blank character */
	SYS_SetVAddr(0x0000);
	for (i=0; i<16; i++)
		VDATA = 0;
	EnableInts();
}

void
UI_CenterString(char *fmt, ...)
{
	va_list		args;
	char			str[128];

	va_start(args,fmt);
	vsprintf(str,fmt,args);
	ScreenCol = 16 - strlen(str);
	UI_PrintLED(str,FALSE);
	va_end(args);
}

void
UI_PrintString(char *fmt, ...)
{
	va_list		args;
	char			str[128];

	va_start(args,fmt);
	vsprintf(str,fmt,args);
	UI_PrintLED(str,FALSE);
	va_end(args);
}

UI_PrintIndicator(UWORD	x,UWORD y, const char *str)
{
	DisableInts();
	ScreenCol = x;
	ScreenRow = y;
	UI_PrintLED(str,TRUE);
	EnableInts();
}

UI_EraseIndicator(UWORD	x,UWORD y, const char *str)
{
	DisableInts();
	ScreenCol = x;
	ScreenRow = y;
	UI_PrintLED(str,FALSE);
	EnableInts();
}

UI_DoMarker(UWORD x,UWORD y,UWORD width,UWORD erase)
{
	DisableInts();
	ScreenRow = y;
	ScreenCol = x - width;
	if (erase)
		UI_PrintLED(" ",FALSE);
	else
		UI_PrintLED(")",FALSE);
	ScreenCol += width;
	if (erase)
		UI_PrintLED(" ",FALSE);
	else
		UI_PrintLED("(",FALSE);
	EnableInts();
}

UI_WaitForKey(volatile register int timeout)
{
	SYS_JoyHit = FALSE;

	EnableInts();
	while (!SYS_JoyHit && timeout--)
		SYS_WaitFrame();
}

int
UI_WaitPress(UWORD frames)
{
	UWORD	i;
	int	done;

	done = FALSE;
	for (i=0; i < frames && !done; i++) {
		if (SYS_JoyTable[JOY_START])
			done = TRUE;
		SYS_WaitFrame();
	}
	return (done);
}

#ifdef EXTRA_INIT_FAILURE_DIAG
extern void EatSomeCycles();
static void EatABunchOfCycles(const int count)
{
	int i;
	for (i = 0; i < count; ++i)
	{
		EatSomeCycles();
	}
}
#endif

UI_CheckIO()
{
	extern WORD		SYS_DOHEADSET;
	extern WORD		SYS_READHEAD;
	extern ULONG	SYS_HMD_ERROR;
	extern void		HMD_INIT_RDY();
	extern WORD		PalBuffer[64];

	SYS_DOHEADSET = SYS_FLICKER = FALSE;
#if HEADTRACK
	DisableInts();
	SYS_ClrPalette();
	UI_Do32();
	UI_LoadLED();
	SetMapPal(&cockpit_map);
	PalBuffer[0] = 0;
	UI_ClearScreen(0xE000);
	UI_ClearScreen(0xC000);
	ScreenRow = 4;
	UI_CenterString("CHECKING FOR");
	ScreenRow = 7;
	UI_CenterString("HEAD TRACKER");
	ScreenRow = 14;
	UI_CenterString("PLEASE");
	ScreenRow = 17;
	UI_CenterString("WAIT");
	SYS_FadeIn(FADETIME);
	DisableInts();
	HMD_INIT_RDY();
	if (SYS_HMD_ERROR == 0l) {
		SYS_READHEAD = SYS_DOHEADSET = 0xFFFF;
		SYS_FLICKER = TRUE; //rww - this was commented out, probably for testing or demo purposes, but i want to enable by default if the headset's detected
		SYS_VR_MODE = 1; //rww - also enable standard stereo mode if we've got a headset
		EnableInts();
		UI_ClearScreen(0xE000);
		ScreenRow = 14;
		UI_CenterString("HEAD TRACKER");
		ScreenRow = 17;
		UI_CenterString("FOUND");
		UI_WaitPress(60*3);
	} else {
		EnableInts();
		UI_WaitPress(60*3);
		UI_ClearScreen(0xE000);
		ScreenRow = 14;
		UI_CenterString("HEAD TRACKER");
		ScreenRow = 17;
		UI_CenterString("NOT FOUND");
#ifdef EXTRA_INIT_FAILURE_DIAG
		ScreenRow = 20;
		UI_CenterString("%08X", SYS_HMD_ERROR);
		
	#if 0 //let's try doing a data read and see what we get
		{
			int i;
			BYTE data[7];
			volatile WORD *pZ80BusReq = (volatile WORD *)0xA11100;
			volatile WORD *pZ80BusReset = (volatile WORD *)0xA11200;
			volatile BYTE *pP2Port = (volatile BYTE *)0xA10005;
			volatile BYTE *pP2PortRW = (volatile BYTE *)0xA1000B;
			
			*pZ80BusReq = 0x100;
			*pZ80BusReset = 0x100;
			while (!((*(volatile BYTE *)pZ80BusReq) & 1));

			*pP2PortRW = 0x60;
			EatSomeCycles();
			
			//try to put it in idle
			*pP2Port = 0x60;
			for (i = 0; i < 0x1000; ++i)
			{
				if ((*pP2Port) & 0x10)
				{
					break;
				}
			}
			data[0] = *pP2Port;
			
			#if 0 //reset/id test
				*pP2Port = 0x40;
				EatABunchOfCycles(0x1000);
				data[1] = *pP2Port;
				*pP2Port = 0x20;
				EatABunchOfCycles(0x100);
				data[2] = *pP2Port;
				*pP2Port = 0x00;
				EatABunchOfCycles(0x100);
				data[3] = *pP2Port;
			#else
				*pP2Port = 0x20;
				EatSomeCycles();
				data[1] = *pP2Port;
				*pP2Port = 0x00;
				EatSomeCycles();
				data[2] = *pP2Port;
				*pP2Port = 0x20;
				EatSomeCycles();
				data[3] = *pP2Port;
				*pP2Port = 0x00;
				EatSomeCycles();
				data[4] = *pP2Port;
				*pP2Port = 0x20;
				EatSomeCycles();
				data[5] = *pP2Port;
			#endif
			
			ScreenRow = 23;
			UI_CenterString("%02X%02X%02X%02X%02X%02X", data[0], data[1], data[2], data[3], data[4], data[5]);
		}
	#endif
		
		UI_WaitPress(60*20);
#else
		UI_WaitPress(60*3);
#endif
	}
	SYS_FadeOut(FADETIME);
#endif
}


static const char *title_story[] = {
/*  0123456789ABCDEF */
	"                ",		/* Screen 1 Line 1 Show NUKERUIN_MAP */
	"     2032 A.D.  ",		/* Screen 1 Line 2 */
	"   ELECTRICITY  ",		/* Screen 1 Line 3 */
	" IS IN DEMAND,  ",		/* Screen 1 Line 4 */
	" BUT THE FOSSIL ",		/* Screen 1 Line 5 */
	" FUELS ARE GONE.",		/* Screen 1 Line 6 */
	"*               ",
	"                ",		/* Screen 2 Line 1 Show NUKERUIN_MAP */
	"   YOUR MISSION:",		/* Screen 2 Line 2 */
	" ACQUIRE RADIO- ",		/* Screen 2 Line 3 */
	" ACTIVE FUEL... ",		/* Screen 2 Line 4 */
	"                ",		/* Screen 2 Line 5 */
	" BY ANY MEANS   ",		/* Screen 2 Line 6 */
	" NECESSARY.     ",		/* Screen 2 Line 7 */
	"*               ",

	"   AN INFORMER, ",		/* Screen 3 Line 1 Show PUNK1_MAP */
	" KNOWN ONLY AS  ",		/* Screen 3 Line 2 */
	" THE CARETAKER, ",		/* Screen 3 Line 3 */
	" TELLS YOU OF   ",		/* Screen 3 Line 4 */
	" SECRET ZONES   ",		/* Screen 3 Line 5 */
	" FULL OF THE    ",		/* Screen 3 Line 6 */
	" WASTE OF OLD-  ",		/* Screen 3 Line 7 */
	" STYLE REACTORS.",		/* Screen 3 Line 8 */
	"*               ",		/* Screen 3 Line 9 */

	"   YOU WILL FIND",		/* Screen 4 Line 1 Show DRONCRSH_MAP */
	" ZONES IN THE   ",		/* Screen 4 Line 2 */
	" HOT DESERTS,   ",		/* Screen 4 Line 3 */
	" THE COLD EMPTY ",		/* Screen 4 Line 4 */
	" TUNDRA, AND IN ",		/* Screen 4 Line 5 */
	" THE RUINS OF   ",		/* Screen 4 Line 6 */
	" FARMLANDS AND  ",		/* Screen 4 Line 7 */
	" DEAD FORESTS.  ",		/* Screen 4 Line 8 */
	"*               ",		/* Screen 4 Line 9 */

	"                ",		/* Screen 5 Line 1 */
	"   BEWARE OF THE",		/* Screen 5 Line 2 */
	" DEADLY FEDERAL ",		/* Screen 5 Line 3 */
	" ROBOT DRONES.  ",		/* Screen 5 Line 4 */
	"                ",		/* Screen 5 Line 5 */
	"   WATCH OUT FOR",		/* Screen 5 Line 6 */
	" YOUR RUTHLESS  ",		/* Screen 5 Line 7 */
	" COMPETITORS.   ",		/* Screen 5 Line 8 */
	"*               ",		/* Screen 5 Line 9 */

	"                ",		/* Screen 6 Line 1 Show PUNK2_MAP */
	"   WELCOME TO   ",		/* Screen 6 Line 2 */
	" THE NUCLEAR    ",		/* Screen 6 Line 3 */
	" RUSH OF 2032.  ",		/* Screen 6 Line 4 */
	"                ",		/* Screen 6 Line 5 */
	"   THE LUCKY WHO",		/* Screen 6 Line 6 */
	" SURVIVE WILL BE",		/* Screen 6 Line 7 */
	" EXTREMELY RICH.",		/* Screen 6 Line 8 */
	"*",

	" PRODUCER:      ",		/* Screen 7 Line 7 Show FP_LOGO_MAP  */
	"  CARL MEY      ",		/* Screen 7 Line 8 */
	"*",

	" DESIGNER /     ",		/* Screen 8 Line 7 */
	" PROGRAMMER:    ",		/* Screen 8 Line 8 */
	"  KEVIN MCGRATH ",		/* Screen 8 Line 9 */
	"*",

	" CO-PROGRAMMER: ",		/* Screen 9 Line 8 */
	" MATTHEW HUBBARD",		/* Screen 9 Line 9 */
	"*",

	" LEAD ARTIST:   ",		/* Screen 10 Line 7 */
	"  TOM COLLIE    ",		/* Screen 10 Line 8 */
	"*",

	" 3D CAD ARTIST: ",		/* Screen 11 Line 7 */
	"  RICK LUCEY    ",		/* Screen 11 Line 8 */
	"*",

	" MUSIC:         ",		/* Screen 12 Line 7 */
	"  DAVORIN KUCHAN",		/* Screen 12 Line 8 */
	"*",

	"RESTORED 2020:  ",
	" RICH WHITEHOUSE",
	"*",
	
	"\0"
};

UI_ShowScreen(UWORD *map)
{
	extern WORD		PalBuffer[64];

#if NOASCII
	SYS_LASTCHR = 1;
#else
	SYS_LASTCHR = 148;
#endif
	DisableInts();
	DispMap(map);
	/* Clear all the background colors */
	PalBuffer[0] = 0;
	PalBuffer[16] = 0;
	PalBuffer[32] = 0;
	PalBuffer[48] = 0;
	EnableInts();
	SYS_FadeIn(FADETIME);						/* Fade new palette in */
}

void
UI_Debounce()
{
	while (SYS_JoyTable[JOY_START])
		SYS_WaitFrame();
}

int
UI_SlowPrint(char *fmt, ...)
{
	int			done,i;
	char			buf[2];
	char			chr;
	va_list		args;
	char			str[128];

	va_start(args,fmt);
	vsprintf(str,fmt,args);
	done = FALSE;
	buf[1] = '\0';
	for (i=0; i < strlen(str) && !done; i++) {
		chr = buf[0] = str[i];
		if (chr != ' ') {
			UI_PrintLED(buf,TRUE);
			done = UI_WaitPress(4);
			if (chr == '.' || chr == ',' || chr == '-')
				ScreenCol--;
			else
				ScreenCol -= 2;
			UI_PrintLED(buf,FALSE);
		} else
			ScreenCol++;
	}
	va_end(args);
	return (done);
}

int
UI_FlashCursor()
{
	int			done,i;

	done = FALSE;
	for (i=0; i < 25 && !done; i++) {
		UI_PrintLED("*",TRUE);
		if (done = UI_WaitPress(4))
			continue;
		ScreenCol -= 2;
		UI_PrintLED("*",FALSE);
		done = UI_WaitPress(4);
		ScreenCol -= 2;
	}
	return (done);
}

void
UI_TitleScreen()
{
	int				button,done,i,j,k;
	int				sx,sy;
	char				*ptr;
	UWORD				frame;
	char				buf[32];
	ULONG				demo_levels;
	extern WORD		PalBuffer[64];
	extern unsigned long		RandomRange(unsigned long max, unsigned long min);
	extern UWORD	WorldNum;
	extern WORD			SYS_DOCYCLE;
	extern WORD			SYS_SCROLLX;
	extern WORD			SYS_NEWXA;
	extern WORD			SYS_NEWXB;

	demo_levels = 0;
restart:
	UI_DemoMode = FALSE;
	UI_InitVDP();
	gemsstopall();
	SYS_ClrPalette();
	UI_ClearScreen(0xC000);
	UI_ClearScreen(0xE000);
	UI_Do40();
	SYS_CHRATTR = 0;
	SegaLogo();
	UI_CheckIO();
	SYS_ClrPalette();
	UI_Do40();			/* Must turn interrupts back on after logo! */
	EnableInts();


	SYS_WaitFrame();
#if NOASCII
	SYS_LASTCHR = 1;
#else
	SYS_LASTCHR = 148;
#endif

	DisableInts();
	DispMap(&backgrnd_map);
	DispBMap(&nukelogo_map);
	InitSprites();
	PDQS_New();
	SendAnimPal(&nukebomb_fpb);
	SYS_SetPalette((UWORD *)&Title_Pal[0]);
	/* Clear all the background colors */
	PalBuffer[0] = 0;
	PalBuffer[16] = 0;
	PalBuffer[32] = 0;
	PalBuffer[48] = 0;
	EnableInts();
	SYS_FadeIn(FADETIME);
	frame = 0;
/*	gemsstartsong(SFX_EXPLOSION); */
	gemsstartsong(VOICE_NUKERUSH);
	done = UI_WaitPress(100);
	gemsstopall();
	if (done)
		goto skip;
	gemsstartsong(MUSIC_TITLE);
	while (!done) {
		SEND_LEFT = TRUE;
		if (frame < 7)
			PDQS_Scale(&nukebomb_fpb,0,frame % 7,97,210,305);
		frame++;
		SetupDMA();								/*	Prepare to DMA sprite data	*/
		done = UI_WaitPress(9);
		PDQS_Init();
		if (frame == 7)
			UI_KillSprList();
		if (frame == 10)
			break;
	}
/*	gemsstopsong(SFX_EXPLOSION); */
skip:
	SYS_FadeOut(FADETIME);						/* Fade old palette out */
	UI_KillSprList();
	UI_Do32();
	UI_LoadLED();
	if (done)
		goto exit;
	i = j = 0;
	done = FALSE;
	buf[1] = '\0';
	while (!done) {
		UI_ClearScreen(0xE000);
		//rww fix - font palette gets stomped by some of the intro screens (may be due to the way i'm auto-detecting palettes when converting images, or may be a legacy issue)
		SYS_SetPalette((UWORD *)&UI_Pal[0]);
		switch (j) {
			case 0:
				UI_ShowScreen(&nukeruin_map);
				break;
			case 2:
				UI_ShowScreen(&punk1_map);
				break;
			case 3:
				UI_ShowScreen(&droncrsh_map);
				break;
			case 5:
				UI_ShowScreen(&punk2_map);
				break;
			case 6:
				/* Do the demo, man... */
				WorldNum = RandomRange(31l,0l);
				/* Make sure we haven't seen this level before */
				k = WorldNum;
				if ((1l << k) & demo_levels) {
					/* Search for the next available level */
					for (k = (k + 1) & 31; k != WorldNum; k = (k + 1) & 31)
						if (!((1l << k) & demo_levels))
							break;
					if (k == WorldNum)
						/* Wrapped all the way around, clear the masks */
						demo_levels = 0;
				}
				demo_levels |= (1l << k);
				WorldNum = k;
				UI_DemoMode = TRUE;
				UI_StopDemo = FALSE;
				MainGameLoop();
				SYS_FadeOut(FADETIME);				/* Fade old palette out */
				UI_InitVDP();
				SYS_DOCYCLE = FALSE;
				UI_KillSprList();
				SYS_NEWXA = SYS_NEWXB = SYS_SCROLLX = 0;
				UI_ClearScreen(0xE000);
				SYS_SetPalette((UWORD *)&UI_Pal[0]);
				gemsstopall();
				gemsstartsong(MUSIC_TITLE);
				if (!UI_DemoMode) {
					SYS_FadeOut(FADETIME);
					goto restart;
				}
				UI_ShowScreen(&fp_logo_map);
				break;
		}
		if (j >= 6)
			sy = 18;
		else
			sy = 2;
		while (title_story[i][0] != '*' && title_story[i][0] != '\0') {
			ScreenRow = sy;
			ScreenCol = 1;
			if (done = UI_SlowPrint((char *)&title_story[i][0]))
				break;
			sy += 3;
			i++;
		}
		if (done) {
			SYS_FadeOut(FADETIME);
			continue;
		}
		ScreenRow = sy;
		ScreenCol = 2;
		done = UI_FlashCursor();
		switch (j) {
			case 1:
			case 2:
			case 4:
			case 5:
			case 12: //11: //rww - snuck myself in there! (sorry, gotta impress the (grand)kids somehow)
				SYS_FadeOut(FADETIME);
				break;
		}
		j++;
		i++;
		if (title_story[i][0] == '\0')
			break;
	}
	if (done) {
		SYS_FadeOut(FADETIME);
		goto restart;
	}
exit:
	if (done)
		SYS_SetPalette((UWORD *)&UI_Pal[0]);
	else
		goto restart;
	return;
}

void	UI_EncodePassword();
int	UI_DecodePassword();

UI_NewGame()
{
	WORD		i;
	extern UWORD	WorldNum;

	for (i=0; i < 8; i++)
		Player.Items[i] = FALSE;
	Player.Missiles = 50;
	Player.Items[1] = TRUE; 
	/* you have lasers and 50 missiles to start level 1 */
	Player.Credits = 0;
	WorldNum = 0;
	UI_EncodePassword();
}

const static struct {
	UWORD		x;
	UWORD		y;
} nsym_locs[32] = {
	64,127,
	73,136,
	113,136,
	82,117,
	115,128,
	45,46,
	60,55,
	64,37,
	89,132,
	109,134,
	97,107,
	65,132,
	70,140,
	74,119,
	149,124,
	127,129,
	53,138,
	73,47,
	106,80,
	158,84,
	158,133,
	43,120,
	118,155,
	71,114,
	96,101,
	67,83,
	146,34,
	162,89,
	88,70,
	80,117,
	98,130,
	84,147
};

void
UI_WorldIntro()
{
	int				done,i;
	extern UWORD	WorldNum;
	extern UWORD	World_Background;
	extern UWORD	World_Time;
	extern WORD		PalBuffer[64];
	extern WORD			SYS_DOCYCLE;

	UI_InitVDP();
	UI_KillSprList();
	UI_ClearScreen(0xE000);
	SYS_SetPalette((UWORD *)&UI_Pal[0]);
#if NOASCII
	SYS_LASTCHR = 1;
#else
	SYS_LASTCHR = 148;
#endif
	DisableInts();
	DispMap(&map_map);
	/* Clear all the background colors */
	PalBuffer[0] = 0;
	PalBuffer[16] = 0;
	PalBuffer[32] = 0;
	PalBuffer[48] = 0;
	EnableInts();
	InitSprites();
	PDQS_New();
	SEND_LEFT = TRUE;
	PDQS_Scale(&nukesym_fpb,0,1,nsym_locs[WorldNum].x,nsym_locs[WorldNum].y,256);
	for (i=31; i >= 0; i--) {
		if (i < WorldNum)
			PDQS_Scale(&nukesym_fpb,0,3,nsym_locs[i].x,nsym_locs[i].y,256);
		else
			if (i > WorldNum)
				PDQS_Scale(&nukesym_fpb,0,2,nsym_locs[i].x,nsym_locs[i].y,256);
			else
				PDQS_Scale(&nukesym_fpb,0,1,nsym_locs[i].x,nsym_locs[i].y,256);
	}
	SetupDMA();								/*	Prepare to DMA sprite data	*/
	PDQS_Init();
	SYS_DOCYCLE = TRUE;
	SYS_FadeIn(FADETIME);				/* Fade new palette in */
	done = FALSE;
	ScreenCol = 10;
	ScreenRow = 3;
	if (UI_SlowPrint("ZONE %d",WorldNum+1))
		goto exit;
	ScreenCol = 3;
	ScreenRow += 4;
	if (UI_SlowPrint("THIS RADIO-"))
		goto exit;
	ScreenCol = 3;
	ScreenRow += 3;
	if (UI_SlowPrint("ACTIVE ZONE IS"))
		goto exit;
	ScreenCol = 3;
	ScreenRow += 3;
	if (World_Background < 4) {
		if (UI_SlowPrint("LOCATED IN THE"))
			goto exit;
	} else
		if (UI_SlowPrint("LOCATED NEAR A"))
			goto exit;
	ScreenCol = 3;
	ScreenRow += 3;
	switch (World_Background) {
		case 0:	/* Midwest */
			done = UI_SlowPrint("PLAINS.");
			break;
		case 1:	/* Ice */
			done = UI_SlowPrint("ARCTIC.");
			break;
		case 2:	/* Desert */
			done = UI_SlowPrint("DESERT.");
			break;
		case 3:	/* Forest */
			done = UI_SlowPrint("FOREST.");
			break;
		case 4:	/* Flaycity */
			done = UI_SlowPrint("PLAINS CITY.");
			break;
		case 5:	/* Froznlab */
			done = UI_SlowPrint("ARCTIC LAB.");
			break;
		case 6:	/* Vegas */
			done = UI_SlowPrint("DESERT CITY.");
			break;
		case 7:	/* Ocean */
			done = UI_SlowPrint("BAY CITY.");
			break;
	}
	if (done)
		goto exit;
	ScreenCol = 3;
	ScreenRow += 6;
	switch (World_Time) {
		case 0:
			done = UI_SlowPrint("IT IS DAY TIME.");
			break;
		case 1:
			done = UI_SlowPrint("IT IS DUSK.");
			break;
		case 2:
			done = UI_SlowPrint("IT IS NIGHT.");
			break;
	}
	if (done)
		goto exit;
	ScreenCol = 3;
	ScreenRow += 3;
	UI_FlashCursor();
exit:
	SYS_FadeOut(FADETIME);
	SYS_DOCYCLE = FALSE;
	UI_KillSprList();
	UI_ClearScreen(0xE000);
	return;
}

static const char *won_story[] = {
/*  0123456789ABCDEF */
	"                ",		/* Screen 1 Line 1 Show UGLYERTH_MAP */
	"  MOST AWSOME.  ",		/* Screen 1 Line 2 */
	"                ",		/* Screen 1 Line 3 */
	" THE WORLD HAD  ",		/* Screen 1 Line 4 */
	" BEEN IN GREAT  ",		/* Screen 1 Line 5 */
	" NEED OF FUEL.  ",		/* Screen 1 Line 6 */
	"*               ",
	"                ",		/* Screen 2 Line 1 Show UGLYERTH_MAP */
	"   YOUR HELP IN ",		/* Screen 2 Line 2 */
	" ACQUIRING THE  ",		/* Screen 2 Line 3 */
	" NUCLEAR FUEL   ",		/* Screen 2 Line 4 */
	" HAS RENEWED AN ",		/* Screen 2 Line 5 */
	" INTREST IN OUR ",		/* Screen 2 Line 6 */
	" ENVIRONMENT.   ",		/* Screen 2 Line 7 */
	"*               ",
	"                ",		/* Screen 3 Line 1 Show GOODERTH_MAP */
	" DUE TO THE NEW ",		/* Screen 3 Line 2 */
	" ENVIRONMENTAL  ",		/* Screen 3 Line 3 */
	" EFFORTS, THE   ",		/* Screen 3 Line 4 */
	" EARTH IS NOW A ",		/* Screen 3 Line 5 */
	" HEALTHY PLACE  ",		/* Screen 3 Line 6 */
	" TO LIVE.       ",		/* Screen 3 Line 7 */
	"*               ",		/* Screen 3 Line 9 */
	"\0"
};

void
UI_GameWon()
{
	int				button,done,i,j,k;
	int				sx,sy;
	char				*ptr;
	UWORD				frame;
	char				buf[32];
	extern WORD		PalBuffer[64];
	extern WORD			SYS_DOCYCLE;
	extern WORD			SYS_SCROLLX;
	extern WORD			SYS_NEWXA;
	extern WORD			SYS_NEWXB;

	SYS_FadeOut(FADETIME);
	UI_InitVDP();
	UI_KillSprList();
	gemsstopall();
	SYS_DOCYCLE = FALSE;
	UI_ClearScreen(0xE000);
	SYS_NEWXA = SYS_NEWXB = SYS_SCROLLX = 0;
	SYS_SetPalette((UWORD *)&UI_Pal[0]);
	i = j = 0;
	done = FALSE;
	buf[1] = '\0';
	while (!done) {
		UI_ClearScreen(0xE000);
		switch (j) {
			case 0:
				UI_ShowScreen(&uglyerth_map);
				break;
			case 2:
				UI_ShowScreen(&gooderth_map);
				break;
		}
		sy = 2;
		while (won_story[i][0] != '*' && won_story[i][0] != '\0') {
			ScreenRow = sy;
			ScreenCol = 1;
			if (done = UI_SlowPrint((char *)&won_story[i][0]))
				break;
			sy += 3;
			i++;
		}
		if (done) {
			SYS_FadeOut(FADETIME);
			continue;
		}
		ScreenRow = sy;
		ScreenCol = 2;
		done = UI_FlashCursor();
		if (j == 1)
			SYS_FadeOut(FADETIME);
		j++;
		i++;
		if (won_story[i][0] == '\0')
			break;
	}
	SYS_FadeOut(FADETIME);
	UI_ClearScreen(0xC000);
	UI_ClearScreen(0xE000);
}

const UWORD	credits_earned[7] =
{
	100,150,200,250,500,500,500
};

void
UI_NextLevel()
{
	WORD					i;
	WORD					done;
	WORD					wait;
	WORD					voice,music;
	char					OutBuf[80];
	extern WORD			SYS_DOCYCLE;
	extern WORD			SYS_SCROLLX;
	extern WORD			SYS_NEWXA;
	extern WORD			SYS_NEWXB;
	extern WORD			Player_Fuel;
	extern UWORD		WorldNum;

	SYS_FadeOut(FADETIME);
	UI_InitVDP();
	gemsstopall();
	SYS_DOCYCLE = FALSE;
	UI_KillSprList();
	SYS_NEWXA = SYS_NEWXB = SYS_SCROLLX = 0;
	SYS_SetPalette((UWORD *)&UI_Pal[0]);
	UI_ClearScreen(0xE000);
	wait = FALSE;
	if (Player_Fuel && Player.Damage) {
		/* Player hasn't run out of fuel and */
		/* player hasn't taken too much damage, so... */
		DisableInts();
		DispMap(&punk2_map);
		EnableInts();
		if (Player.Won) {
			/* Convert Gieger level to Credits */
			Player.Credits += credits_earned[WorldNum / 5];
			if (Player.Credits >= 2048)
				Player.Credits = 2047;
			WorldNum++;
			Player_Fuel = 31;
			UI_EncodePassword();
			wait = TRUE;
			ScreenRow = 4;
			UI_CenterString("LEVEL COMPLETE");
			ScreenRow = 20;
			UI_CenterString("NEW CODE");
			ScreenRow = 23;
			UI_CenterString(UI_AccessCode);
		} else {
			if (SYS_JoyTable[JOY_UP])
				if (WorldNum < 31)
					WorldNum++;
				else
					WorldNum = 0;
			if (SYS_JoyTable[JOY_DOWN])
				if (WorldNum > 0)
					WorldNum--;
				else
					WorldNum = 31;
		}
		voice = VOICE_MISSIONS;
		music = MUSIC_WIN;
	} else {
		DisableInts();
		if (Player.Damage)
			DispMap(&punk1_map);
		else
			DispMap(&droncrsh_map);
		EnableInts();
		UI_Continue++;
		if (UI_Continue >= (UI_NumContinues + 3)) {
			ScreenRow = 18;
			UI_CenterString("GAME OVER");
			UI_NewGame();
		}
		if (Player.Damage) {
			ScreenRow = 20;
			UI_CenterString("OUT OF FUEL");
		} else {
			ScreenRow = 8;
			UI_CenterString("SHOT DOWN");
		}
		voice = VOICE_GAME_OVR;
		music = MUSIC_LOOSE;
	}
	SYS_FadeIn(FADETIME);
	gemsstartsong(voice);
	done = UI_WaitPress(80);
	if (done)
		gemsstopall();
	else {
		gemsstartsong(music);
		if (!wait)
			UI_WaitPress(500);
	}
	if (wait) {
		char		buf[40];

		UI_Debounce();
		while (!SYS_JoyTable[JOY_START])
			SYS_WaitFrame();
		/* Show Statistics screen */
		UI_ClearScreen(0xE000);
		ScreenRow = 10;
		UI_CenterString("HIT RATIO");
		ScreenRow = 13;
		i = (STATS_HITS != 0) ? (STATS_SHOTS / STATS_HITS) : 0; //rww fix - crash when cleared with no hits
		if (i)
			sprintf(buf,"%d PERCENT",100 / i);
		else
			strcpy(buf,"0 PERCENT");
		UI_CenterString(buf);
		UI_Debounce();
		UI_WaitPress(500);
	}
	SYS_FadeOut(FADETIME);
	UI_ClearScreen(0xC000);
	UI_ClearScreen(0xE000);
	//rww fix - restore palettes since game over screens can stomp pal3 and make the rest of the menus look wrong
	SYS_SetPalette((UWORD *)&Title_Pal[0]);
	SYS_SetPalette((UWORD *)&UI_Pal[0]);	
}

static const char	*start_items[] = {
	"PLAYER START",
	"ACCESS CODE",
	"OPTIONS",
#if FOCUS
	"FOCUS",
#if TEST_ANM
	"TEST ANIMS"
#else
	"CHEAT MENU"
#endif
#else
#if TEST_ANM
	"TEST ANIMS"
#else
	"CHEAT MENU"
#endif
#endif
};

static const char	*start_items2[] = {
	"CONTINUE",
	"NEW GAME"
};

int
UI_StartScreen()
{
	int				cur_item,old_item,done,last_move,button;
	extern UWORD	nukescrn_map;

/*	SYS_SetPalette(UI_Pal); */
	if (UI_DecodePassword() > 1) { //rww fix - allow -1 result
		SYS_FadeIn(FADETIME);
		Bomb("Bad Password in StartScreen()\n %s",UI_AccessCode);
	}
restart:
	if (UI_Continue >= (UI_NumContinues + 3))
		UI_Continue = 0;
#if NOASCII
	SYS_LASTCHR = 1;
#else
	SYS_LASTCHR = 148;
#endif
	DisableInts();
	DispMap(&nukescrn_map);
	EnableInts();
	UI_ClearScreen(0xE000);
	/* Display menu */
	ScreenRow = 4;
	UI_CenterString("Nuclear Rush");
	if (UI_Continue) {
		for (cur_item = 0; cur_item < 2; cur_item++)
			UI_EraseIndicator(4,cur_item*3+10,start_items2[cur_item]);
	} else {
#if FOCUS
		for (cur_item = 0; cur_item < 5; cur_item++)
#else
		for (cur_item = 0; cur_item < 4; cur_item++)
#endif
			UI_EraseIndicator(4,cur_item*3+10,start_items[cur_item]);
	}
	/* Let user select menu item */
	last_move = -1;
	cur_item = 0;
	done = FALSE;
	button = TRUE;
	if (UI_Continue)
		UI_PrintIndicator(4,cur_item*3+10,start_items2[cur_item]);
	else
		UI_PrintIndicator(4,cur_item*3+10,start_items[cur_item]);
		
	SYS_FadeIn(FADETIME);						/* Fade new palette in */
	while (!done) {
		old_item = cur_item;
		if (SYS_JoyTable[JOY_UP]) {
			if (last_move != JOY_UP) {
				last_move = JOY_UP;
				if (cur_item)
					cur_item--;
			}
		} else
			if (SYS_JoyTable[JOY_DOWN]) {
				if (last_move != JOY_DOWN) {
					last_move = JOY_DOWN;
#if FOCUS
					if (cur_item < (UI_Continue ? 1 : 4))
#else
					if (cur_item < (UI_Continue ? 1 : 3))
#endif
						cur_item++;
				}
			} else
				last_move = -1;
		if (old_item != cur_item) {
			if (UI_Continue) {
				UI_EraseIndicator(4,old_item*3+10,start_items2[old_item]);
				UI_PrintIndicator(4,cur_item*3+10,start_items2[cur_item]);
			} else {
				UI_EraseIndicator(4,old_item*3+10,start_items[old_item]);
				UI_PrintIndicator(4,cur_item*3+10,start_items[cur_item]);
			}
			gemsstartsong(SFX_BUTTON_HIT);
		}
		if (SYS_JoyTable[JOY_START]) {
			if (button)
				continue;
			gemsstartsong(SFX_BUTTON_ON);
			done = TRUE;
		} else
			button = FALSE;
		SYS_WaitFrame();
	}
	SYS_FadeOut(FADETIME);						/* Fade old palette out */
	UI_ClearScreen(0xE000);
	if (UI_Continue && cur_item == 1) { //rww fix - was &, meant to be &&
		extern UWORD	WorldNum;
		UI_Continue = 0;
		WorldNum = 0; //rww fix - start back at world 0 when selecting new game
		goto restart;
	}
	return (cur_item);
}

const static char	*levels[4] = {
	"EASY    ",
	"MEDIUM",
	"HARD    ",
	"KILLER"
};

#if WCES94
const static char	*vr_modes[4] = {
	"MONO     ",
	"STEREO 1",
	"STEREO 2",
	"STEREO   "
};
#endif

const static char	*opt_items[] = {
	"EXIT",
	"LEVEL",
	"CONTINUES",
	"SOUND TEST",
#if WCES94
	"MONO",
#else
	"CONTROL:",
#endif
	"VSCROLL" //rww
};

#define	MAX_SONGS	30

extern int gWantVCellScrollEnabled;

const static WORD	songs[] = {
	0,1,2,4,5,6,7,8,10,16,17,18,19,20,21,22,23,
	24,25,26,27,28,29,30,31,32,33,34,35,36
};

UI_OptionScreen()
{
	const int itemCount = 6; //rww - changed from 5
	int	cur_item,old_item,done,last_move;
	int	level;
	int	last_button;
	WORD	song;
	char	buf[4];
	extern UWORD	gridscrn_map;
	extern WORD		SYS_DOHEADSET;

	song = 0;
#if NOASCII
	SYS_LASTCHR = 1;
#else
	SYS_LASTCHR = 148;
#endif
	DisableInts();
	DispMap(&gridscrn_map);
	EnableInts();
	UI_ClearScreen(0xE000);
	/* Display menu */
	ScreenRow = 4;
	UI_CenterString("Game Options");
	for (cur_item = 0; cur_item < itemCount; cur_item++)
		UI_EraseIndicator(4,cur_item*3+8,opt_items[cur_item]);
	ScreenCol = 16;
	ScreenRow = 11;
	UI_PrintString((char *)levels[UI_GameLevel]);
	ScreenCol = 26;
	ScreenRow = 14;
	buf[0] = UI_NumContinues + '3';
	buf[1] = '\0';
	UI_PrintString(buf);
	ScreenCol = 24;
	ScreenRow = 17;
	UI_PrintString("%2d ",song);
#if WCES94
	UI_EraseIndicator(4,4*3+8,vr_modes[SYS_VR_MODE]);
#else
	ScreenRow = 23;
	if (UI_Control)
		UI_CenterString("ALT MISL LZR");
	else
		UI_CenterString("LZR MISL ALT");
#endif

	//rww - added vscroll option
	ScreenRow = 23;
	ScreenCol = 26;
	buf[0] = gWantVCellScrollEnabled + '0';
	buf[1] = '\0';
	UI_PrintString(buf);					


	/* Let user select menu item */
	last_move = -1;
	cur_item = 0;
	last_button = TRUE;
	done = FALSE;
	UI_PrintIndicator(4,cur_item*3+8,opt_items[cur_item]);
	SYS_FadeIn(FADETIME);						/* Fade new palette in */
	while (!done) {
		old_item = cur_item;
		if (SYS_JoyTable[JOY_UP]) {
			if (last_move != JOY_UP) {
				last_move = JOY_UP;
				if (cur_item)
					cur_item--;
			}
		} else
			if (SYS_JoyTable[JOY_DOWN]) {
				if (last_move != JOY_DOWN) {
					last_move = JOY_DOWN;
					if (cur_item < (itemCount - 1))
						cur_item++;
				}
			} else
				if (cur_item == 3) {
					if (SYS_JoyTable[JOY_LEFT]) {
						if (last_move != JOY_LEFT) {
							last_move = JOY_LEFT;
							if (song > 0)
								song--;
							ScreenCol = 24;
							ScreenRow = 17;
							UI_PrintString("%2d ",song);
						}
					} else
						if (SYS_JoyTable[JOY_RIGHT]) {
							if (last_move != JOY_RIGHT) {
								last_move = JOY_RIGHT;
								if (song < MAX_SONGS - 1)
									song++;
								ScreenCol = 24;
								ScreenRow = 17;
								UI_PrintString("%2d ",song);
							}
						} else
							last_move = -1;
				} else
					last_move = -1;
		if (old_item != cur_item) {
#if WCES94
			if (old_item == 4)
				UI_EraseIndicator(4,old_item*3+8,vr_modes[SYS_VR_MODE]);
			else
				UI_EraseIndicator(4,old_item*3+8,opt_items[old_item]);
			if (cur_item == 4)
				UI_PrintIndicator(4,cur_item*3+8,vr_modes[SYS_VR_MODE]);
			else
				UI_PrintIndicator(4,cur_item*3+8,opt_items[cur_item]);
#else
			UI_EraseIndicator(4,old_item*3+8,opt_items[old_item]);
			UI_PrintIndicator(4,cur_item*3+8,opt_items[cur_item]);
#endif
			gemsstartsong(SFX_BUTTON_HIT);
			SYS_WaitFrame();
		}
		if (SYS_JoyTable[JOY_START]) {
			/* Update interactive menu items */
			if (last_button)
				continue;
			last_button = TRUE;
			gemsstartsong(SFX_BUTTON_ON);
			switch (cur_item) {
				case 0:	/* Return to Main Menu */
					done = TRUE;
					break;
				case 1:	/* Player Level */
					ScreenRow = 11;
					ScreenCol = 16;
					UI_GameLevel++;
					UI_GameLevel &= 3;
					UI_PrintString((char *)levels[UI_GameLevel]);
					break;
				case 2:	/* Number of Drones */
					ScreenRow = 14;
					ScreenCol = 26;
					UI_NumContinues++;
					UI_NumContinues &= 3;
					buf[0] = UI_NumContinues + '3';
					buf[1] = '\0';
					UI_PrintString(buf);
					break;
				case 3:	/* Sound Test */
					gemsstopall();
					gemsstartsong(songs[song]);
					break;
				case 4:	/* Control */
#if WCES94
					SYS_VR_MODE++;
					SYS_VR_MODE &= 3;
					UI_PrintIndicator(4,cur_item*3+8,vr_modes[SYS_VR_MODE]);
					if (SYS_VR_MODE)
						SYS_FLICKER = TRUE;
					else
						SYS_FLICKER = FALSE;
#else
					ScreenRow = 23;
					UI_Control ^= 1;
					if (UI_Control)
						UI_CenterString("ALT MISL LZR");
					else
						UI_CenterString("LZR MISL ALT");
#endif
					break;
				case 5: //rww - vscroll mode
					gWantVCellScrollEnabled = (gWantVCellScrollEnabled + 1) % 4;
					ScreenRow = 23;
					ScreenCol = 26;
					buf[0] = gWantVCellScrollEnabled + '0';
					buf[1] = '\0';
					UI_PrintString(buf);					
					break;
			}
		} else
			last_button = FALSE;
	}
	SYS_FadeOut(FADETIME);						/* Fade old palette out */
	UI_ClearScreen(0xE000);
	return (cur_item);
}

typedef struct {
	UWORD		x;
	UWORD		y;
	UWORD		up;
	UWORD		down;
	UWORD		left;
	UWORD		right;
	char		*name;
} ACCESS_ITEM;

static const char *ASCII2CODE = "BCDGHJKLMNPSTVWX";

const static ACCESS_ITEM a_items[18] = {
	/* X,Y Up, Dn, Lt, Rt, Name */
	 8,12, 16,  4,  3,  1, "B",
	14,12, 16,  5,  0,  2, "C",
	20,12, 17,  6,  1,  3, "D",
	26,12, 17,  7,  2,  0, "G",
	 8,14, 0,   8,  7,  5, "H",
	14,14, 1,   9,  4,  6, "J",
	20,14, 2,  10,  5,  7, "K",
	26,14, 3,  11,  6,  4, "L",
	 8,16, 4,  12, 11,  9, "M",
	14,16, 5,  13,  8, 10, "N",
	20,16, 6,  14,  9, 11, "P",
	26,16, 7,  15, 10,  8, "S",
	 8,18, 8,  16, 15, 13, "T",
	14,18, 9,  16, 12, 14, "V",
	20,18,10,  17, 13, 15, "W",
	26,18,11,  17, 14, 12, "X",
	 8,20,13,   1, 17, 17, "Back",
	18,20,14,   2, 16, 16, "Enter"
};

/***
 *			Password Structure:	32-Bit long bitfield
 *			Don't mess with this too much, the bitfield stuff is backwards
 *			and will most likely cause a great deal of confusion.
 ***/

typedef struct {
	ULONG		Protect:4,		/* XOR/Checksum password verifier */
				Lasers:1,
				Cloak:1,
				Infrared:1,
				Gieger:1,
				Engine:1,
				Shields:1,		/* Player drone enhancements: */
				Missiles:6,		/* Accumulated missiles 0-63 */
				Credits:11,		/* Accumulated credits */
				World:5;			/* World number, 0-31 */
} PASSWORD;

PASSWORD		UI_Password;

void
UI_EncodePassword()
{
	WORD				i,j;
	WORD				chksum;
	ULONG				tmp;
	ULONG				*ptr;
	extern UWORD	WorldNum;

	UI_Password.World = WorldNum;
	UI_Password.Credits = Player.Credits;
	UI_Password.Missiles = Player.Missiles;
	UI_Password.Shields = Player.Items[3];
	UI_Password.Engine = Player.Items[4];
	UI_Password.Gieger = Player.Items[2];
	UI_Password.Infrared = Player.Items[0];
	UI_Password.Cloak = Player.Items[5];
	UI_Password.Lasers = Player.Items[1];

	ptr = (ULONG *)&UI_Password;
	tmp = *ptr;
	chksum = 0;
	for (i=0; i < 7; i++) {
		tmp >>= 4;
		chksum += tmp & 0xF;
	}
	UI_Password.Protect = chksum ^ 0xA;
	tmp = *ptr;
	for (i=7; i >= 0; i--) {
		j = tmp & 0xF;
		tmp >>= 4;
		UI_AccessCode[i] = a_items[j].name[0];
	}
	UI_AccessCode[8] = '\0';
}

/***
 *		UI_DecodePassword():  Returns TRUE if password is bad.
 *		rww fix - changed to return 1 for bad, 0 for good, -1 for invalid characters to avoid special checking for "        "
 ***/

int
UI_DecodePassword()
{
	WORD				i,j,k;
	WORD				chksum;
	ULONG				tmp;
	ULONG				decoded;
	extern UWORD	WorldNum;

	tmp = 0l;
	for (i=0; i < 8; i++) {
		tmp <<= 4;
		for (k=0; k < 16; k++)
			if (UI_AccessCode[i] == ASCII2CODE[k])
				break;
		if (k == 16)
			/* We NEVER should be able to get this... */
			//Bomb("Bad Password (%s)!",UI_AccessCode);
			return -1; //rww fix - we can get this, just by leaving some blank characters in the password - space isn't mapped. so, we handle it.
		tmp |= k;
	}
	decoded = tmp;
	chksum = 0;
	for (i=0; i < 7; i++) {
		tmp >>= 4;
		chksum += tmp & 0xF;
	}
	chksum = (chksum ^ 0xA) & 0xF;
	if (chksum != k)
		return 1;//TRUE;
	*(ULONG *)&UI_Password = decoded;
	WorldNum = UI_Password.World;
	Player.Credits = UI_Password.Credits;
	Player.Missiles = UI_Password.Missiles;
	if (UI_Password.Shields)
		Player.Items[3] = TRUE;
	else
		Player.Items[3] = FALSE;
	if (UI_Password.Engine)
		Player.Items[4] = TRUE;
	else
		Player.Items[4] = FALSE;
	if (UI_Password.Gieger)
		Player.Items[2] = TRUE;
	else
		Player.Items[2] = FALSE;
	if (UI_Password.Infrared)
		Player.Items[0] = TRUE;
	else
		Player.Items[0] = FALSE;
	if (UI_Password.Cloak)
		Player.Items[5] = TRUE;
	else
		Player.Items[5] = FALSE;
	if (UI_Password.Lasers)
		Player.Items[1] = TRUE;
	else
		Player.Items[1] = FALSE;
	return 0;//FALSE;
}

int
UI_PasswordScreen()
{
	int	cur_item,old_item,done,last_move,button;
	char	buf[4];
	int	i,x,y;
	int	code_len;
	int decodeResult; //rww fix - recognize invalid entry as just "go back to menu"
	extern UWORD	gridscrn_map;

restart:
#if NOASCII
	SYS_LASTCHR = 1;
#else
	SYS_LASTCHR = 148;
#endif
	DisableInts();
	DispMap(&gridscrn_map);
	EnableInts();
	UI_ClearScreen(0xE000);
	/* Display menu */
	ScreenRow = 4;
	UI_CenterString("Zone Code");
	ScreenRow = 8;
	ScreenCol = 4;
	UI_PrintString("CODE:");
	/* Print access code character array */
	buf[1] = '\0';
	for (i=0; i<18; i++)
		UI_EraseIndicator(a_items[i].x,a_items[i].y,a_items[i].name);
	/* Let user enter access code */
	strcpy(UI_AccessCode,"        ");
	code_len = 0;
	last_move = -1;
	button = TRUE;
	cur_item = 0;
	UI_PrintIndicator(a_items[cur_item].x,a_items[cur_item].y,
		a_items[cur_item].name);
	done = FALSE;
	SYS_FadeIn(FADETIME);						/* Fade new palette in */
	do {
		old_item = cur_item;
		if (SYS_JoyTable[JOY_UP]) {
			if (last_move != JOY_UP) {
				last_move = JOY_UP;
				cur_item = a_items[cur_item].up;
			}
		} else
			if (SYS_JoyTable[JOY_DOWN]) {
				if (last_move != JOY_DOWN) {
					last_move = JOY_DOWN;
					cur_item = a_items[cur_item].down;
				}
			} else
				if (SYS_JoyTable[JOY_LEFT]) {
					if (last_move != JOY_LEFT) {
						last_move = JOY_LEFT;
						cur_item = a_items[cur_item].left;
					}
				} else
					if (SYS_JoyTable[JOY_RIGHT]) {
						if (last_move != JOY_RIGHT) {
							last_move = JOY_RIGHT;
							cur_item = a_items[cur_item].right;
						}
					} else
						last_move = -1;
		if (old_item != cur_item) {
			UI_EraseIndicator(a_items[old_item].x,a_items[old_item].y,
				a_items[old_item].name);
			UI_PrintIndicator(a_items[cur_item].x,a_items[cur_item].y,
				a_items[cur_item].name);
			gemsstartsong(SFX_BUTTON_HIT);
		}
		/* Let user select a key */
		if (SYS_JoyTable[JOY_START]) {
			if (button)
				continue;
			gemsstartsong(SFX_BUTTON_ON);
			button = TRUE;
			if (cur_item < 16) {
				/* Limit string input to 8 digits */
				if (code_len < 8)
					UI_AccessCode[code_len++] = a_items[cur_item].name[0];
				else
					UI_AccessCode[code_len-1] = a_items[cur_item].name[0];
			}
			if (cur_item == 16)
				if (code_len) {
					code_len--;
					UI_AccessCode[code_len] = ' ';
				}
			if (cur_item == 17)
				done = TRUE;
			ScreenRow = 8;
			ScreenCol = 14;
			UI_PrintString(UI_AccessCode);
		} else
			button = FALSE;
		SYS_WaitFrame();
	} while (!done);
	decodeResult = UI_DecodePassword();
	if (decodeResult > 0) { //rww fix - let space be handled naturally (before we were checking for "        ", but after the call to UI_DecodePassword. we probably meant to make the check before the call instead.
		UI_ClearScreen(0xE000);
		ScreenRow = 12;
		UI_CenterString("ILLEGAL CODE");
		ScreenRow = 15;
		UI_CenterString("TRY AGAIN");
		UI_Debounce();
		UI_WaitPress(600);
		goto restart;
	}
	SYS_FadeOut(FADETIME);						/* Fade old palette out */
	UI_ClearScreen(0xE000);
	if (decodeResult < 0) //rww fix - let space be handled naturally //strcmp(UI_AccessCode,"        ") == 0)
		return (FALSE);
	else
		return (TRUE);
}

UI_GameDemo()
{
}

#if FOCUS
/***
 *		AdjustFocus:		A user routine to adjust the minimum and maximum
 *								distances for flickering.
 ***/

#define	MAXSCALE		600

UI_AdjustFocus()
{
	int				button,done;
	extern UWORD	focus_map;
	UWORD				scale;
	UWORD				dist;
	UWORD				x;

	extern WORD		PalBuffer[64];

#if NOASCII
	SYS_LASTCHR = 1;
#else
	SYS_LASTCHR = 148;
#endif
	UI_ClearScreen(0xC000);
	DisableInts();
	DispMap(&focus_map);
	EnableInts();
	InitSprites();
	PDQS_New();
#if 0
	/*	Some more DMA setup	*/
	SYS_BASECHR1 = SYS_LASTCHR;		/*	Get base character address for spites	*/
	SYS_BASECHR = SYS_BASECHR1;
#endif
	UI_ClearScreen(0xE000);
	SendAnimPal(&house32_fpb);
	/* Display menu */
	ScreenCol = 4;
	ScreenRow = 4;
	UI_PrintString("FOCAL ADJUST");
	done = FALSE;
#if 0
	SYS_FLICKER = TRUE;
#endif
	dist = 0x100;
#if 0
	ScreenRow = 18;
	ScreenCol = 0;
	Debug("  Joy Up increases distance.");
	Debug("  Joy Down decreases distance.");
	Debug("  Joy A & Up/Down sets Minimum.");
	Debug("  Joy C & Up/Down sets Maximum.");
#endif
	EnableInts();

	SYS_FadeIn(FADETIME);						/* Fade new palette in */
	scale = 0;
	while (!done) {
#if 1
		ScreenCol = 4;
		ScreenRow = 1;
		UI_PrintString("S=%3d <%02X >%02X",scale,SYS_MINFDIST,SYS_MAXFDIST);
#endif

		/* Simulate the correct scale factor (from 3D.C68) */
		scale = (((unsigned long)dist) << 16) / (unsigned short)0xDFFF;
		scale = MAXSCALE - scale;
		//if (scale < 0)
		if (scale & 0x8000) //rww fix
			scale = 0;
		if (scale > MAXSCALE)
			scale = MAXSCALE;
		/* Compute new Distance Divisor */
		SYS_DISTDIV = MAXSCALE / (SYS_MAXFDIST - SYS_MINFDIST);
		x = (scale / SYS_DISTDIV) + SYS_MINFDIST;

		SEND_LEFT = TRUE;
		ScreenRow = 1;
		ScreenCol = 2;
		PDQS_Scale(&house32_fpb,0,0,128+x,124,scale);
		if (SYS_FLICKER) {
			SEND_LEFT = FALSE;
			SetSendRight();
			PDQS_Scale(&house32_fpb,0,0,128-x,124,scale);
		}
		SetupDMA();								/*	Prepare to DMA sprite data	*/
		PDQS_Init();
	 	SYS_WaitFrame();
		if (SYS_JoyTable[JOY_A] || SYS_JoyTable[JOY_B] ||
			SYS_JoyTable[JOY_C] || SYS_JoyTable[JOY_START]) {
			if (SYS_JoyTable[JOY_A]) {
				if (SYS_JoyTable[JOY_UP])
					if (SYS_MINFDIST > 0)
						SYS_MINFDIST--;
				if (SYS_JoyTable[JOY_DOWN])
					if (SYS_MINFDIST < (SYS_MAXFDIST-1))
						SYS_MINFDIST++;
			} else
				if (SYS_JoyTable[JOY_C]) {
					if (SYS_JoyTable[JOY_UP])
						if (SYS_MAXFDIST > (SYS_MINFDIST+1))
							SYS_MAXFDIST--;
					if (SYS_JoyTable[JOY_DOWN])
						if (SYS_MINFDIST < 100)
							SYS_MAXFDIST++;
				} else
					done = TRUE;
			/* Compute average reading distance from Min and Max */
			SYS_AVGFDIST = ((SYS_MAXFDIST - SYS_MINFDIST) / 2) + SYS_MINFDIST;
		} else {
			if (SYS_JoyTable[JOY_UP])
				if (dist < MAXSCALE)
					dist++;
			if (SYS_JoyTable[JOY_DOWN])
				if (dist > 0)
					dist--;
		}
	}
/* 	SYS_DOHEADSET = 0xFFFF; */
/* 	SYS_FLICKER = TRUE; */
	UI_KillSprList();
	SYS_FadeOut(FADETIME);						/* Fade old palette out */
}
#endif

/***
 *		DrawArrow:		Routine to draw the arrow or blank on the Enhance screen
 ***/

static void
DrawArrow(WORD x,WORD y,WORD flip,WORD chr_index,WORD chr_inc)
{
	UWORD				*vdata;
	UWORD				Addr;
	UWORD				scrn_x,scrn_y;
	short				i,j;

	vdata = (UWORD *)0xC00000;
#if NOASCII
	chr_index += 1;				/* Start at begining of Enhance map */
#else
	chr_index += 148;				/* Start at begining of Enhance map */
#endif
	scrn_y = y;
	DisableInts();
	for (i=0; i < 2; i++) {
		if (flip)
			scrn_x = x + 2;
		else
			scrn_x = x;
		for (j=0; j < 3; j++) {
			/* Compute address of character to print */
			Addr = (scrn_y * (64 * 2)) + (scrn_x * 2) + 0xC000;
			SYS_SetVAddr(Addr);
			*vdata = chr_index + (flip ? 0x0800: 0) + 0x6000;
			chr_index += chr_inc;
			if (flip)
				scrn_x--;
			else
				scrn_x++;
		}
		scrn_y++;
	}
	EnableInts();
}


/***
 *		UI_DroneEnhance:	Drone Enhancement interface...
 ***/

const static WORD		Item_Costs[] = {
	200,100,50,150,400,600,10,0
};

UI_DroneEnhance()
{
	int				button,done;
	int				last_move;
	int				item,i,last_item;
	UWORD				frame;
	short				before,	/* Item before current one that we can afford */
						after;	/* Item after current one that we can afford */
	WORD				old_credits;

	UI_KillSprList();
	gemsstopall();
	gemsstartsong(MUSIC_EXTRA);
	UI_InitVDP();
#if NOASCII
	SYS_LASTCHR = 1;
#else
	SYS_LASTCHR = 148;
#endif
	DisableInts();
	DispMap(&enhance_map);
	EnableInts();
	UI_ClearScreen(0xE000);

	/*	Set up variables so that we can display sprites here... */
	DisableInts();
	InitSprites();
	SendAnimPal(&player_anm);

/*	SYS_CHRATTR = 0x8000; */
	EnableInts();
	SYS_FadeIn(FADETIME);						/* Fade new palette in */
	frame = 0;
	/* Find the first item that we can afford */
	i = 0;
	after = -1;
	do {
		if (Item_Costs[i] <= Player.Credits && !Player.Items[i])
			after = i;
		else
			i = (i < 7 ? i+1 : 0);
	} while (after == -1);
	item = after;
	old_credits = last_item = last_move = -1;
	done = FALSE;
	while (!done) {
		SEND_LEFT = TRUE;
		/* Display all items currently on players ship */
		if (Player.Items[5])
			DispFrame(&disolve_anm,0,frame % 7,124,104);
		if (Player.Items[3])
			DispFrame(&forcefld_anm,0,frame % 12,97,48);
		if (Player.Items[4])
			DispFrame(&player_anm,0,1,127,104);
		if (Player.Items[0])
			DispFrame(&player_anm,0,2,126,104);
		if (Player.Items[2])
			DispFrame(&player_anm,0,3,126,104);
		if (Player.Items[1])
			DispFrame(&player_anm,0,4,126,104);

		if (old_credits != Player.Credits) {
			old_credits = Player.Credits;
			ScreenCol = 3;
			ScreenRow = 1;
			UI_PrintString("                          ");
			ScreenCol = 3;
			ScreenRow = 1;
			UI_CenterString("%d CREDITS",Player.Credits);
		}
		if (last_item != item) {
			if (last_item == 7) {
				/* Erase text in window */
				ScreenRow = 18;
				ScreenCol = 8;
				UI_PrintString("                ");
				ScreenRow = 20;
				ScreenCol = 8;
				UI_PrintString("                ");
			}
			last_item = item;
			ScreenRow = 24;
			ScreenCol = 4;
			UI_PrintString("                          ");
			ScreenRow = 24;
			switch (item) {
				case 0:
					UI_CenterString("INFRARED %d",Item_Costs[item]);
					break;
				case 1:
					UI_CenterString("LASER %d",Item_Costs[item]);
					break;
				case 2:
					UI_CenterString("GEIGER %d",Item_Costs[item]);
					break;
				case 3:
					UI_CenterString("SHIELD %d",Item_Costs[item]);
					break;
				case 4:
					UI_CenterString("ENGINE %d",Item_Costs[item]);
					break;
				case 5:
					UI_CenterString("CLOAKING %d",Item_Costs[item]);
					break;
				case 6:
					UI_CenterString("MISSILES %d",Item_Costs[item]);
					break;
				case 7:
					/* Kill sprite list if no sprites showing on screen! */
					after = FALSE;
					for (i=0; i < 7; i++)
						if (Player.Items[i])
							after = TRUE;
					if (!after)
						UI_KillSprList();
					ScreenRow = 18;
					UI_CenterString("CONTINUE");
					ScreenRow = 20;
					UI_CenterString("GAME");
					break;
			}
		}
		switch (item) {
			case 0:
				DispFrame(&infrared_anm,0,frame % 11,129,181);
				break;
			case 1:
				DispFrame(&lasergun_anm,0,frame % 4,129,173);
				break;
			case 2:
				DispFrame(&oozemap_anm,0,frame % 24,129,175);
				break;
			case 3:
				DispFrame(&shield_anm,0,frame % 10,129,182);
				break;
			case 4:
				DispFrame(&engine_anm,0,frame % 8,120,173);
				break;
			case 5:
				DispFrame(&cloak_anm,0,frame % 7,129,181);
				break;
			case 6:
				DispFrame(&missles_anm,0,frame % 8,129,167);
				break;
			case 7:
				break;
		}

		frame++;
		SetupDMA();								/*	Prepare to DMA sprite data	*/
		for (i=0; i<5; i++)
		 	SYS_WaitFrame();
		/* Make buttons ready for next movement */
		DrawArrow(3,19,TRUE,280,1);
		DrawArrow(26,19,FALSE,280,1);
		if (SYS_JoyTable[JOY_START]) {
			/* Quit if user selected "Continue Game" */
			if (item == 7)
				done = TRUE;
			else {
				/* Buy item */
				gemsstartsong(SFX_BUTTON_ON);
				if (item == 6) {
						Player.Missiles += 20;
						if (Player.Missiles > 63)
							Player.Missiles = 63;
				} else
					Player.Items[item] = TRUE;
				Player.Credits -= Item_Costs[item];
				/* Find the item after the current one that we can afford */
				i = item;
				after = -1;
				do {
					i = (i < 7 ? i+1 : 0);
					if (Item_Costs[i] <= Player.Credits) 
						if (i < 6) {
							if (!Player.Items[i])
								after = i;
						} else
						  	after = i;
				} while (after == -1);
				item = after;
			}
			UI_Debounce();
		} else {
			/* Find the item before the current one that we can afford */
			i = item;
			before = -1;
			do {
				i = (i ? i-1 : 7);
				if (Item_Costs[i] <= Player.Credits)
					if (i < 6) {
						if (!Player.Items[i])
							before = i;
					} else 
						before = i;
			} while (before == -1);
			/* Find the item after the current one that we can afford */
			i = item;
			after = -1;
			do {
				i = (i < 7 ? i+1 : 0);
				if (Item_Costs[i] <= Player.Credits)
					if (i < 6) {
						if (!Player.Items[i])
							after = i;
					} else
						after = i;
			} while (after == -1);
			/* Move to new item if needed */
			if (SYS_JoyTable[JOY_LEFT]) {
				if (last_move != JOY_LEFT) {
					last_move = JOY_LEFT;
					DrawArrow(3,19,TRUE,286,1);
					item = before;
					gemsstartsong(SFX_BUTTON_HIT);
				}
			} else
				if (SYS_JoyTable[JOY_RIGHT]) {
					if (last_move != JOY_RIGHT) {
						DrawArrow(26,19,FALSE,286,1);
						last_move = JOY_RIGHT;
						item = after;
						gemsstartsong(SFX_BUTTON_HIT);
					}
				} else
					last_move = -1;
		}
	}
	UI_KillSprList();
	SYS_FadeOut(FADETIME);						/* Fade old palette out */
	//rww fix - restore palettes since this screen stomps pal3
	SYS_SetPalette((UWORD *)&Title_Pal[0]);
	SYS_SetPalette((UWORD *)&UI_Pal[0]);
	gemsstopall();
}

/***
 *		Nuclear Rush Cheat menu
 ***/

static const char	*cheat_items[] = {
	"EXIT",
	"WORLD",
	"BUY ITEMS"
};

UI_Cheat()
{
	int	cur_item,old_item,done,last_move;
	int	level;
	int	last_button;
	char	buf[4];
	extern UWORD	gridscrn_map;
	extern WORD		SYS_DOHEADSET;
	extern UWORD	WorldNum;

	if (UI_DecodePassword()) {
		SYS_FadeIn(FADETIME);
		Bomb("Bad Password in Cheat()\n %s",UI_AccessCode);
	}
restart:
#if NOASCII
	SYS_LASTCHR = 1;
#else
	SYS_LASTCHR = 148;
#endif
	DisableInts();
	DispMap(&gridscrn_map);
	EnableInts();
	UI_ClearScreen(0xE000);
	/* Display menu */
	ScreenRow = 4;
	UI_CenterString("Cheat Options");
	for (cur_item = 0; cur_item < 3; cur_item++)
		UI_EraseIndicator(4,cur_item*3+10,cheat_items[cur_item]);
	ScreenCol = 16;
	ScreenRow = 13;
	UI_PrintString("%2d ",WorldNum + 1);
	/* Let user select menu item */
	last_move = -1;
	cur_item = 0;
	last_button = TRUE;
	done = FALSE;
	UI_PrintIndicator(4,cur_item*3+10,cheat_items[cur_item]);
	SYS_FadeIn(FADETIME);						/* Fade new palette in */
	while (!done) {
		old_item = cur_item;
		if (SYS_JoyTable[JOY_UP]) {
			if (last_move != JOY_UP) {
				last_move = JOY_UP;
				if (cur_item)
					cur_item--;
			}
		} else
			if (SYS_JoyTable[JOY_DOWN]) {
				if (last_move != JOY_DOWN) {
					last_move = JOY_DOWN;
					if (cur_item < 2)
						cur_item++;
				}
			} else
				last_move = -1;
		if (old_item != cur_item) {
			UI_EraseIndicator(4,old_item*3+10,cheat_items[old_item]);
			UI_PrintIndicator(4,cur_item*3+10,cheat_items[cur_item]);
			gemsstartsong(SFX_BUTTON_HIT);
			SYS_WaitFrame();
		}
		if (SYS_JoyTable[JOY_START]) {
			/* Update interactive menu items */
			if (last_button)
				continue;
			last_button = TRUE;
			gemsstartsong(SFX_BUTTON_ON);
			switch (cur_item) {
				case 0:	/* Return to Main Menu */
					done = TRUE;
					break;
				case 1:	/* Player World */
					ScreenRow = 13;
					ScreenCol = 16;
					WorldNum++;
					WorldNum &= 31;
					UI_PrintString("%2d ",WorldNum + 1);
					break;
				case 2:	/* Buy Items */
					Player.Credits = 2000;
					SYS_FadeOut(FADETIME);
					UI_DroneEnhance();
					goto restart;
					break;
			}
		} else
			last_button = FALSE;
	}
	SYS_FadeOut(FADETIME);						/* Fade old palette out */
	UI_ClearScreen(0xE000);
	return (cur_item);
}

#if TEST_ANM
/***
 *		UI_TestAnms:		A user routine to show all animations, to make
 *								sure there are no bugs!
 ***/

UWORD		*anims[] = {
	&cactus_fpb,
	&joshua_fpb,
	&pear_fpb,
	&sagebush_fpb,
	&grass_fpb,
	&maple_fpb,
	&oak_fpb,
	&rock_fpb,
	&sealbone_fpb,
	&tombston_fpb,
	&wellruin_fpb,
	&igloo32_fpb,
	&jeep_fpb,
	&explode_fpb,
	&pool_fpb,
	&zoomer32_fpb,
	&can32_fpb,
	&fed32_fpb,
	&gramps32_fpb,
	&mine32_fpb,
	&missle32_fpb,
	&mod32_fpb,
	&rcr32_fpb,
	&drift1_fpb,
	&drift2_fpb,
	&drift3_fpb,
	&drift4_fpb,
	&house32_fpb,
	&tank32_fpb,
	&zzap_fpb,
	&piece1_fpb,
	&piece2_fpb,
	&piece3_fpb,
	&piece4_fpb,
	&piece5_fpb,
	&piece6_fpb,
	&nukebomb_fpb,
	&buoy1_fpb,
	&buoy2_fpb,
	&marker1_fpb,
	&marker2_fpb,
	&oilpump_fpb,
	&silo_fpb,
	&sphrtank_fpb,
	&grndtank_fpb,
	&nukesym_fpb,
	&wave_fpb,
	0
};


UWORD
Get_NumFrames(UWORD *anm_file)
{
	UWORD				*anim_ptr;	/* Pointer to animation */
	UWORD				*wptr;		/* Temporary pointer */

	wptr = anm_file;							/*	Base of animation file	*/
	wptr++;										/*	Skip palette offset	*/
	/*	Add animation list offset	*/
	anim_ptr = (UWORD *)((BYTE *)anm_file + *wptr);
	return (*anim_ptr);
}

UI_TestAnms()
{
	UWORD				i,j,k;

	extern WORD		PalBuffer[64];

#if NOASCII
	SYS_LASTCHR = 1;
#else
	SYS_LASTCHR = 148;
#endif
	UI_ClearScreen(0xC000);
	UI_ClearScreen(0xE000);
	InitSprites();
	PDQS_New();
#if 0
	/*	Some more DMA setup	*/
	SYS_BASECHR1 = SYS_LASTCHR;		/*	Get base character address for spites	*/
	SYS_BASECHR = SYS_BASECHR1;
#endif
	/* Display menu */
	ScreenRow = 4;
	UI_CenterString("ANIM TEST");
	EnableInts();

	SYS_FadeIn(FADETIME);						/* Fade new palette in */
	SEND_LEFT = TRUE;
	for (i=0; anims[i]; i++) {
	 	SYS_WaitFrame();
		SendAnimPal(anims[i]);
		PalBuffer[0] = 0;
		SYS_SendPalette();
		k = Get_NumFrames(anims[i]);
		for (j=0; j < k; j++) {
			PDQS_Scale(anims[i],0,j,128,180,512);
			SetupDMA();								/*	Prepare to DMA sprite data	*/
			PDQS_Init();
		 	SYS_WaitFrame();
		}
	}
	UI_KillSprList();
	SYS_FadeOut(FADETIME);						/* Fade old palette out */
}
#endif

/***
 *		Do_UI:	Start Game, Show Logo, Run interface screens
 ***/

Main_UI()
{
	int				done;
	extern UWORD	SYS_CHRATTR;		/* Character Attributes */
	extern WORD		SYS_SCRLXB;
	
	SYS_SCRLXB = 0;
	SYS_CHRATTR = 0;
	done = FALSE;
	gemsstopall();
	gemsstartsong(MUSIC_OPENING);
	do {
		switch (UI_StartScreen()) {
			case 0:	/* Continue/Player Start */
				done = TRUE;
				break;
			case 1:	/* Access Code */
				done = UI_PasswordScreen();
				break;
			case 2:	/* Options */
				UI_OptionScreen();
				break;
#if FOCUS
			case 3:	/* Focus Adjustment */
				UI_AdjustFocus();
				break;
#else
			case 3:	/* Cheat menu */
#endif
			case 4:
#if TEST_ANM
				UI_TestAnms();
#else
				UI_Cheat();
				UI_EncodePassword();
#endif
				break;
		}
	} while (!done);	
}

Do_UI()
{
	gemsinit(&patchbank, &envbank, &seqbank, &sampbank);
	UI_Control = FALSE;
	UI_NewGame();
	UI_TitleScreen();
	SendAnimPal(&fed32_fpb);
}
